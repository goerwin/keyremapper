#pragma once

#include <ApplicationServices/ApplicationServices.h>
#include <iostream>
#include <chrono>
#include "./Global.hpp"

class MouseHandler {
private:
  static int clickCount;
  static CGPoint mouseLoc;
  static std::string status;
  static std::string mouseType;
  static double lastPressTime;
  static CFMachPortRef myEventTap;
  static CFRunLoopSourceRef myRunLoopSource;

public:
  static double doubleClickSpeed;

public:
  static void handleMouseDownUp(bool isMouseDown, std::string mouseType = "left") {
    //get current mouse position
    CGEventRef tempEvent = CGEventCreate(NULL);
    CGPoint newMouseLoc = CGEventGetLocation(tempEvent);

    if (isMouseDown) {
      double now = std::chrono::system_clock::now().time_since_epoch() / std::chrono::milliseconds(1);

      if (
        MouseHandler::mouseType != mouseType ||
        newMouseLoc.x != MouseHandler::mouseLoc.x ||
        newMouseLoc.y != MouseHandler::mouseLoc.y ||
        clickCount == 0 ||
        now - lastPressTime > doubleClickSpeed
      ) clickCount = 1;
      else clickCount = clickCount + 1;

      MouseHandler::mouseType = mouseType;
      MouseHandler::mouseLoc = newMouseLoc;
      lastPressTime = now;
    }

    MouseHandler::status = isMouseDown ? "mouse_is_down" : "mouse_is_up";

    auto eventType = isMouseDown ?
      mouseType == "right" ?
        kCGEventRightMouseDown : kCGEventLeftMouseDown :
      mouseType == "right" ?
        kCGEventRightMouseUp : kCGEventLeftMouseUp;
    auto buttonType = mouseType == "right" ? kCGMouseButtonRight : kCGMouseButtonLeft;
    CGEventRef event = CGEventCreateMouseEvent(NULL, eventType, newMouseLoc, buttonType);
    CGEventSetIntegerValueField(event, kCGMouseEventClickState, clickCount);
    CGEventSetDoubleValueField(event, kCGEventSourceUserData, 69);
    setModifierFlagsToNativeMouseEvent(event, false);
    CGEventPost(kCGHIDEventTap, event);
    CFRelease(tempEvent);
    CFRelease(event);
  }

  static void setModifierFlagsToNativeMouseEvent(CGEventRef event, bool isNativeEvent) {
    CGEventFlags flags = 0;

    if (Global::isCmdDown) flags = flags | kCGEventFlagMaskCommand;
    if (Global::isShiftDown) flags = flags | kCGEventFlagMaskShift;
    if (Global::isAltDown) flags = flags | kCGEventFlagMaskAlternate;
    if (Global::isCtrlDown) flags = flags | kCGEventFlagMaskControl;
    if (Global::isFnDown) flags = flags | kCGEventFlagMaskSecondaryFn;

    if (!isNativeEvent) return CGEventSetFlags(event, flags);

    auto eventType = CGEventGetType(event);
    bool isMoving = eventType == kCGEventMouseMoved;
    bool isDragging = eventType == kCGEventLeftMouseDragged || eventType == kCGEventRightMouseDragged;

    if (!isMoving && !isDragging) return CGEventSetFlags(event, flags);

    // if it's moving or dragging, convert event to drag if mouse_is_down
    if (MouseHandler::status == "mouse_is_down") {
      CGEventSetType(event,
        MouseHandler::mouseType == "left" ? kCGEventLeftMouseDragged : kCGEventRightMouseDragged);
    } else if (MouseHandler::status == "mouse_is_up") {
      CGEventSetType(event, kCGEventMouseMoved);
      MouseHandler::status = {};
    }

    return CGEventSetFlags(event, flags);
  }

  static void initialize() {
    // apparently, real mouse events don't register modifier presses generated by this app. So I have to listen for mouse events and attach the modifier flags accordingly
      // NOTE: kCGEventTapOptionListenOnly does not fail when clicking the app's menu bar but it doesnt let me
      // modify the event
    myEventTap = CGEventTapCreate(kCGHIDEventTap, kCGHeadInsertEventTap, kCGEventTapOptionDefault,
      CGEventMaskBit(kCGEventLeftMouseDown) |
      CGEventMaskBit(kCGEventLeftMouseUp) |
      CGEventMaskBit(kCGEventLeftMouseDragged) |
      CGEventMaskBit(kCGEventRightMouseDown) |
      CGEventMaskBit(kCGEventRightMouseUp) |
      CGEventMaskBit(kCGEventRightMouseDragged) |
      CGEventMaskBit(kCGEventMouseMoved),
      [](CGEventTapProxy proxy, CGEventType type, CGEventRef event, void *refcon) {
        auto userData = CGEventGetDoubleValueField(event, kCGEventSourceUserData);

        // only attach flags to native mouse events
        if (userData != 69) setModifierFlagsToNativeMouseEvent(event, true);

        return event;
        }, NULL);

    if (!myEventTap) {
      std::cout << "Accesibility disabled for this app";
      exit(1);
      return;
    }

    myRunLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, myEventTap, 0);

    if (!myRunLoopSource) {
      std::cout << "Couldn't create runLoopSource";
      exit(1);
      return;
    }

    // NOTE: kCFRunLoopCommonModes removes the issue of clicking the app's menubar
    // kCFRunLoopDefaultMode has issue with clicking the app's menubar
    // Seems that on xcode's menubar doesnt work when running it from it :(
    CFRunLoopAddSource(CFRunLoopGetMain(), myRunLoopSource, kCFRunLoopCommonModes);


  }

  static void terminate() {
    if (myEventTap) {
      CFMachPortInvalidate(myEventTap);
      CFRelease(myEventTap);
    }

    if (myRunLoopSource) {
      CFRunLoopRemoveSource(CFRunLoopGetMain(), myRunLoopSource, kCFRunLoopCommonModes);
      CFRelease(myRunLoopSource);
    }
  }
};

CGPoint MouseHandler::mouseLoc;
std::string MouseHandler::status = "";
std::string MouseHandler::mouseType;
int MouseHandler::clickCount = 0;
double MouseHandler::lastPressTime = 0;
double MouseHandler::doubleClickSpeed = 500;
CFMachPortRef MouseHandler::myEventTap;
CFRunLoopSourceRef MouseHandler::myRunLoopSource;

