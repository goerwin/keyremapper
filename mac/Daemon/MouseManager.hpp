#pragma once

#include <ApplicationServices/ApplicationServices.h>
#include <iostream>
#include <chrono>
#include "./Global.hpp"

class MouseManager {
private:
  static int clickCount;
  static CGPoint mouseLoc;
  static std::string status;
  static std::string mouseType;
  static double lastPressTime;
  static CFMachPortRef myEventTap;
  static CFRunLoopSourceRef myRunLoopSource;

public:
  static double doubleClickSpeed;

public:
  static void handleMouseDownUp(bool isMouseDown, std::string mouseType = "left") {
    //get current mouse position
    CGEventRef tempEvent = CGEventCreate(NULL);
    CGPoint newMouseLoc = CGEventGetLocation(tempEvent);

    if (isMouseDown) {
      double now = std::chrono::system_clock::now().time_since_epoch() / std::chrono::milliseconds(1);

      if (
        MouseManager::mouseType != mouseType ||
        newMouseLoc.x != MouseManager::mouseLoc.x ||
        newMouseLoc.y != MouseManager::mouseLoc.y ||
        clickCount == 0 ||
        now - lastPressTime > doubleClickSpeed
      ) clickCount = 1;
      else clickCount = clickCount + 1;
      
      // NOTE: When assigning to a static variable, ensure you prefix the ClassName
      MouseManager::mouseType = mouseType;
      MouseManager::mouseLoc = newMouseLoc;
      lastPressTime = now;
    }

    MouseManager::status = isMouseDown ? "mouse_is_down" : "mouse_is_up";

    auto eventType = isMouseDown ?
      mouseType == "right" ?
        kCGEventRightMouseDown : kCGEventLeftMouseDown :
      mouseType == "right" ?
        kCGEventRightMouseUp : kCGEventLeftMouseUp;
    auto buttonType = mouseType == "right" ? kCGMouseButtonRight : kCGMouseButtonLeft;
    CGEventRef event = CGEventCreateMouseEvent(NULL, eventType, newMouseLoc, buttonType);
    CGEventSetIntegerValueField(event, kCGMouseEventClickState, clickCount);
    CGEventSetDoubleValueField(event, kCGEventSourceUserData, 69);
    setModifierFlagsToNativeMouseEvent(event, false);
    CGEventPost(kCGHIDEventTap, event);
    CFRelease(tempEvent);
    CFRelease(event);
  }

  static void setModifierFlagsToNativeMouseEvent(CGEventRef event, bool isNativeEvent) {
    CGEventFlags flags = 0;

    if (Global::isCmdDown) flags = flags | kCGEventFlagMaskCommand;
    if (Global::isShiftDown) flags = flags | kCGEventFlagMaskShift;
    if (Global::isAltDown) flags = flags | kCGEventFlagMaskAlternate;
    if (Global::isCtrlDown) flags = flags | kCGEventFlagMaskControl;
    if (Global::isFnDown) flags = flags | kCGEventFlagMaskSecondaryFn;

    if (!isNativeEvent) return CGEventSetFlags(event, flags);

    auto eventType = CGEventGetType(event);
    bool isMoving = eventType == kCGEventMouseMoved;
    bool isDragging = eventType == kCGEventLeftMouseDragged || eventType == kCGEventRightMouseDragged;

    if (!isMoving && !isDragging) return CGEventSetFlags(event, flags);

    // if it's moving or dragging, convert event to drag if mouse_is_down
    if (MouseManager::status == "mouse_is_down") {
      CGEventSetType(event,
        MouseManager::mouseType == "left" ? kCGEventLeftMouseDragged : kCGEventRightMouseDragged);
    } else if (MouseManager::status == "mouse_is_up") {
      CGEventSetType(event, kCGEventMouseMoved);
      MouseManager::status = {};
    }

    return CGEventSetFlags(event, flags);
  }

  static int start() {
    // apparently, real mouse events don't register modifier presses generated by this app. So I have to listen for mouse events and attach the modifier flags accordingly
      // NOTE: kCGEventTapOptionListenOnly does not fail when clicking the app's menu bar but it doesnt let me
      // modify the event
    MouseManager::myEventTap = CGEventTapCreate(kCGHIDEventTap, kCGHeadInsertEventTap, kCGEventTapOptionDefault,
      CGEventMaskBit(kCGEventLeftMouseDown) |
      CGEventMaskBit(kCGEventLeftMouseUp) |
      CGEventMaskBit(kCGEventLeftMouseDragged) |
      CGEventMaskBit(kCGEventRightMouseDown) |
      CGEventMaskBit(kCGEventRightMouseUp) |
      CGEventMaskBit(kCGEventRightMouseDragged) |
      CGEventMaskBit(kCGEventMouseMoved),
      [](CGEventTapProxy proxy, CGEventType type, CGEventRef event, void *refcon) {
        auto userData = CGEventGetDoubleValueField(event, kCGEventSourceUserData);

        // only attach flags to native mouse events
        if (userData != 69) setModifierFlagsToNativeMouseEvent(event, true);

        return event;
        }, NULL);

    // Accesibility disabled for this app
    if (!MouseManager::myEventTap) return 1;

    MouseManager::myRunLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, MouseManager::myEventTap, 0);

    // Couldn't create runLoopSource
    if (!MouseManager::myRunLoopSource) return 2;

    // NOTE: kCFRunLoopCommonModes removes the issue of clicking the app's menubar
    // kCFRunLoopDefaultMode has issue with clicking the app's menubar
    // Seems that on xcode's menubar doesnt work when running it from it :(
    CFRunLoopAddSource(CFRunLoopGetMain(), MouseManager::myRunLoopSource, kCFRunLoopCommonModes);
    return 0;
  }

  static void stop() {
    if (MouseManager::myEventTap) {
      CFMachPortInvalidate(MouseManager::myEventTap);
      CFRelease(MouseManager::myEventTap);
      MouseManager::myEventTap = nil;
    }

    if (MouseManager::myRunLoopSource) {
      CFRunLoopRemoveSource(CFRunLoopGetMain(), MouseManager::myRunLoopSource, kCFRunLoopCommonModes);
      CFRelease(MouseManager::myRunLoopSource);
      MouseManager::myRunLoopSource = nil;
    }
  }
};

CGPoint MouseManager::mouseLoc;
std::string MouseManager::status = "";
std::string MouseManager::mouseType;
int MouseManager::clickCount = 0;
double MouseManager::lastPressTime = 0;
double MouseManager::doubleClickSpeed = 500;
CFMachPortRef MouseManager::myEventTap;
CFRunLoopSourceRef MouseManager::myRunLoopSource;

